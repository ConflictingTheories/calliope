{"version":3,"sources":["../../node_modules/@uiw/react-markdown-preview/node_modules/prismjs/components/prism-lisp.js"],"names":["Prism","simple_form","name","RegExp","primitive","pattern","symbol","par","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","lisp","elisp","emacs"],"mappings":"2IAAC,SAAUA,GAIV,SAASC,EAAYC,GACpB,OAAOC,OAAO,QAAUD,EAAO,gBAGhC,SAASE,EAAUC,GAClB,OAAOF,OAAO,YAAcE,EAAU,cAOvC,IAAIC,EAAS,yBAITC,EAAM,QAKNC,EAAW,CAGdC,QAAS,CACRJ,QAAS,QACTK,MAAO,CAAC,UAAW,UAEpBC,QAAS,MACTC,OAAQ,CACPP,QAAS,oBACTQ,QAAQ,EACRC,OAAQ,CACPC,SAAU,oBACVT,OAAQH,OAAO,IAAMG,EAAS,OAGhC,gBAAiB,CAChBD,QAASF,OAAO,MAAQG,GACxBI,MAAO,CAAC,WAAY,WAErB,gBAAiB,CAChBL,QAASF,OAAO,IAAMG,GACtBI,MAAO,YAERM,OAAQ,CACPX,QAASF,OAAO,MAAQG,GACxBI,MAAO,CAAC,SAAU,aAEnBO,QAAS,CACR,CACCZ,QAASF,OACRI,wJAIDW,YAAY,GAEb,CACCb,QAASF,OACRI,kEAEDW,YAAY,IAGdC,QAAS,CACRd,QAASJ,EAAY,WACrBiB,YAAY,EACZR,MAAO,WAERU,YAAa,CACZf,QAASJ,EAAY,eACrBiB,YAAY,EACZR,MAAO,WAERW,QAAS,CACRhB,QAASD,EAAU,aACnBc,YAAY,GAEbI,OAAQ,CACPjB,QAASD,EAAU,yBACnBc,YAAY,GAEbK,OAAQ,CACPlB,QAASF,OAAOI,EAAM,oCAAsCD,GAC5DY,YAAY,EACZJ,OAAQ,CACPG,QAAS,aACTO,SAAUrB,OAAOG,KAGnBmB,MAAO,CACNpB,QAASF,OACRI,EACC,qCACAD,EACA,wBAEFY,YAAY,EACZJ,OAAQ,CACPG,QAAS,kBAGTS,UAAW,KACXC,SAAU,CACTtB,QAASF,OAAO,SAAWG,GAC3BY,YAAY,GAEbU,YAAa,SAGfC,OAAQ,CACPxB,QAASF,OAAOI,EAAM,qBAAuBD,EAAS,aACtDY,YAAY,EACZJ,OAAQ,CACPG,QAAS,UAGTS,UAAW,KACXE,YAAa,SAGfE,IAAK,CACJzB,QAASF,OAAOI,EAAMD,GACtBY,YAAY,GAEbU,YAAa,CAEZ,uBAEA,CACCvB,QAAS,eACTa,YAAY,KAKXa,EAAM,CACT,cAAe5B,OA5HH,2BA6HZ6B,KAAM,CACLjB,SAAU,CACTV,QAASF,OAAOG,GAChBI,MAAO,YAERuB,QAAS,CACR5B,QAASF,OAAOI,EAAMD,EAANC,2BAChBW,YAAY,EACZJ,OAAQ,CACPF,OAAQJ,EAASI,OACjBS,QAASb,EAASa,QAClBC,OAAQd,EAASc,OACjBhB,OAAQE,EAASF,OACjBsB,YAAa,WAMbM,EAAQ,oBAERC,EAAU,CACb9B,QAASF,OAAOI,sBAChBW,YAAY,EACZJ,OAAQ,CACP,YAAa,CACZT,QAASF,OAAO,qBAAuB+B,GACvCpB,OAAQiB,GAET,oBAAqB,CACpB1B,QAASF,OAAO,wBAA0B+B,GAC1CpB,OAAQiB,GAETK,KAAM,CACL/B,QAASF,OAAO,WAAa+B,EAAQ,8BACrCpB,OAAQiB,GAEThB,SAAU,CACTV,QAASF,OAAOG,GAChBI,MAAO,YAERkB,YAAa,SAIfpB,EAAQ,OAAWM,OAAOY,UAAYS,EACtC3B,EAAQ,MAAUM,OAAOY,UAAY1B,EAAMqC,KAAKC,MAAMH,GACtD3B,EAAQ,MAAUM,OAAOY,UAAUZ,OAAOyB,QAAUJ,EAEpDnC,EAAMwC,UAAUC,KAAOjC,EACvBR,EAAMwC,UAAUE,MAAQlC,EACxBR,EAAMwC,UAAUG,MAAQnC,EACxBR,EAAMwC,UAAU,cAAgBhC,EAnMhC,CAoMCR","file":"static/js/236.2bbfe9ee.chunk.js","sourcesContent":["(function (Prism) {\n\t// Functions to construct regular expressions\n\t// simple form\n\t// e.g. (interactive ... or (interactive)\n\tfunction simple_form(name) {\n\t\treturn RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n\t}\n\t// booleans and numbers\n\tfunction primitive(pattern) {\n\t\treturn RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n\t}\n\n\t// Patterns in regular expressions\n\n\t// Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n\t// & and : are excluded as they are usually used for special purposes\n\tvar symbol = '[-+*/_~!@$%^=<>{}\\\\w]+';\n\t// symbol starting with & used in function arguments\n\tvar marker = '&' + symbol;\n\t// Open parenthesis for look-behind\n\tvar par = '(\\\\()';\n\tvar endpar = '(?=\\\\))';\n\t// End the pattern with look-ahead space\n\tvar space = '(?=\\\\s)';\n\n\tvar language = {\n\t\t// Three or four semicolons are considered a heading.\n\t\t// See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n\t\theading: {\n\t\t\tpattern: /;;;.*/,\n\t\t\talias: ['comment', 'title']\n\t\t},\n\t\tcomment: /;.*/,\n\t\tstring: {\n\t\t\tpattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\targument: /[-A-Z]+(?=[.,\\s])/,\n\t\t\t\tsymbol: RegExp('`' + symbol + \"'\")\n\t\t\t}\n\t\t},\n\t\t'quoted-symbol': {\n\t\t\tpattern: RegExp(\"#?'\" + symbol),\n\t\t\talias: ['variable', 'symbol']\n\t\t},\n\t\t'lisp-property': {\n\t\t\tpattern: RegExp(':' + symbol),\n\t\t\talias: 'property'\n\t\t},\n\t\tsplice: {\n\t\t\tpattern: RegExp(',@?' + symbol),\n\t\t\talias: ['symbol', 'variable']\n\t\t},\n\t\tkeyword: [\n\t\t\t{\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\tpar +\n\t\t\t\t\t\t'(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' +\n\t\t\t\t\t\tspace\n\t\t\t\t),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\tpar + '(?:for|do|collect|return|finally|append|concat|in|by)' + space\n\t\t\t\t),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t],\n\t\tdeclare: {\n\t\t\tpattern: simple_form('declare'),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\t\tinteractive: {\n\t\t\tpattern: simple_form('interactive'),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\t\tboolean: {\n\t\t\tpattern: primitive('(?:t|nil)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\tnumber: {\n\t\t\tpattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n\t\t\tlookbehind: true\n\t\t},\n\t\tdefvar: {\n\t\t\tpattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^def[a-z]+/,\n\t\t\t\tvariable: RegExp(symbol)\n\t\t\t}\n\t\t},\n\t\tdefun: {\n\t\t\tpattern: RegExp(\n\t\t\t\tpar +\n\t\t\t\t\t'(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' +\n\t\t\t\t\tsymbol +\n\t\t\t\t\t'\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^(?:cl-)?def\\S+/,\n\t\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t\t// reference the language object.\n\t\t\t\targuments: null,\n\t\t\t\tfunction: {\n\t\t\t\t\tpattern: RegExp('(^\\\\s)' + symbol),\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\tpunctuation: /[()]/\n\t\t\t}\n\t\t},\n\t\tlambda: {\n\t\t\tpattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\tkeyword: /^lambda/,\n\t\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t\t// reference the language object.\n\t\t\t\targuments: null,\n\t\t\t\tpunctuation: /[()]/\n\t\t\t}\n\t\t},\n\t\tcar: {\n\t\t\tpattern: RegExp(par + symbol),\n\t\t\tlookbehind: true\n\t\t},\n\t\tpunctuation: [\n\t\t\t// open paren, brackets, and close paren\n\t\t\t/(?:['`,]?\\(|[)\\[\\]])/,\n\t\t\t// cons\n\t\t\t{\n\t\t\t\tpattern: /(\\s)\\.(?=\\s)/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t]\n\t};\n\n\tvar arg = {\n\t\t'lisp-marker': RegExp(marker),\n\t\trest: {\n\t\t\targument: {\n\t\t\t\tpattern: RegExp(symbol),\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\tvarform: {\n\t\t\t\tpattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\tstring: language.string,\n\t\t\t\t\tboolean: language.boolean,\n\t\t\t\t\tnumber: language.number,\n\t\t\t\t\tsymbol: language.symbol,\n\t\t\t\t\tpunctuation: /[()]/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n\n\tvar arglist = {\n\t\tpattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'rest-vars': {\n\t\t\t\tpattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\t'other-marker-vars': {\n\t\t\t\tpattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\tkeys: {\n\t\t\t\tpattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n\t\t\t\tinside: arg\n\t\t\t},\n\t\t\targument: {\n\t\t\t\tpattern: RegExp(symbol),\n\t\t\t\talias: 'variable'\n\t\t\t},\n\t\t\tpunctuation: /[()]/\n\t\t}\n\t};\n\n\tlanguage['lambda'].inside.arguments = arglist;\n\tlanguage['defun'].inside.arguments = Prism.util.clone(arglist);\n\tlanguage['defun'].inside.arguments.inside.sublist = arglist;\n\n\tPrism.languages.lisp = language;\n\tPrism.languages.elisp = language;\n\tPrism.languages.emacs = language;\n\tPrism.languages['emacs-lisp'] = language;\n}(Prism));\n"],"sourceRoot":""}